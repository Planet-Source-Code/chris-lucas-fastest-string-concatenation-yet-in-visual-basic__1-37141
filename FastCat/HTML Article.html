<p><font size = 6><font color = blue><u>Features</u></p>
<UL>
<font color = black>
<font size = 4>
<LI>Faster than anything else (check out screenshot!)</LI>
<LI>No API calls</LI>
<LI>Fully configurable at runtime</LI>
</UL>
<br>

<font color = blue>
<p><font size = 6><u>Method</u></p>
<font color = black>
<font size = 4>
<p>&nbsp&nbsp&nbsp&nbspThe buffering scheme I've come up with is simplicity itself.&nbsp&nbspRather than allocating
increasingly large buffers only to move the previous buffer into the new buffer I've taken a different approach.&nbsp&nbsp
My buffer is a string array.&nbsp&nbspWhen one string fills up the class simply moves on to the next string in the array.&nbsp&nbsp
While this seems like a minor change it has two very profound effects on string concatenation.&nbsp&nbspFirst, this approach speeds
concatenation up dramatically.&nbsp&nbspThis is because buffers are never moved around which obviously takes time.&nbsp&nbspSecond, much
larger strings are possible because unlike conventional buffering schemes paged buffering does not require one huge and continous
chunk of memory.
</p>
<br>

<font color = blue>
<p><font size = 6><u>Implementation</u></p>
<font color = black>
<font size = 4>
<p>&nbsp&nbsp&nbsp&nbspPaged buffering string concatenation is best implemented as a class module.&nbsp&nbspI've named this class 
<font color = red>cFastCat<font color = black>
and implemented it as follows:

<p><font color = blue>Read / Write Properties</p><font color = black>
<UL>
<LI>BufferPages - Sets/returns the number of pages contained in the buffer</LI>
<LI>BufferPageSize - Sets/returns the size of each buffer page</LI>
</UL>
</p>

<p><font color = blue>Read Only Properties</p><font color = black>
<UL>
<LI>Value - Returns the current string in the buffer.&nbsp&nbspThis is the default property of <font color = red>cFastCat<font color = black></LI>
<LI>TotalBufferSize - Returns the amount of space in bytes the buffer is currently using.&nbsp&nbspBecause the buffer does not
by default free its resources this space can be different from the size of the string in the buffer</LI>
<LI>StringLength - Returns the length in characters of the string in the buffer</LI>
<LI>StringLengthB - Returns the length in bytes of the string in the buffer</LI>
</UL>
</p>

<p><font color = blue>Methods</p><font color = black>
<UL>
<LI>Append - Concatenates the passed string onto the end of the buffer</LI>
<LI>Flush - Empties the buffer</LI>
<LI>ReleaseMemory - Frees all currently consumed resources</LI>
</UL>
</p>
<br>

<font color = blue>
<p><font size = 6><u>Don't Take My Word For it</u></p>
<font color = black>
<font size = 4>
<p>&nbsp&nbsp&nbsp&nbspI've included everything in the zip.&nbsp&nbspA demonstration project is included as well as a full article complete
with graphs of the timing results for a variety of calls.&nbsp&nbspNothing is faster and all the proof is free for the downloading.  Please
leave your votes and feedback.
</p>
<br>